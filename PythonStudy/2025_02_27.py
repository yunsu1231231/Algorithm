# 자료형 
# 숫자, 문자열, 불, 변수, 리스트 ,튜플, 딕셔너리, 

# 숫자형
# 정수형, 실수형 # int, float 

a = 1.2
print(type(a)) # <class 'float'>

# 파이썬 모든 자료형은 객체로 저장 
# 예를 들어, a = 10이라면 숫자 10은 메모리의 특정 주소에 할당
# 이 객체는 참조를 통해 접근 
# a = 10이라면, a는 10이라는 객체가 저장된 메모리의 주소를 참조하는 변수

# 파이썬에서는 객체가 참조로 전달됩니다. 
# 즉, 변수를 다른 변수에 할당하거나 함수에 인자로 넘길 때, 객체 자체를 복사하는 것이 아니라 그 객체의 참조(주소값)가 전달
# 예를 들어, 리스트를 함수에 넘길 때, 리스트 객체 자체가 복사되지 않고 리스트 객체가 저장된 메모리 주소를 전달하게 됩니다. 
# 따라서 함수 내에서 객체를 수정하면, 원본 객체도 수정

a = 10
b = a  # a의 참조를 b에 전달

print(id(a))  # a의 메모리 주소
print(id(b))  # b의 메모리 주소

# 결과가 같다면 a와 b는 같은 객체를 참조하고 있다는 뜻

def modify_list(lst):
    lst.append(4)  # 리스트에 4를 추가

original_list = [1, 2, 3]  # 원본 리스트
print("Before function call:", original_list)

modify_list(original_list)  # 함수에 리스트를 넘김

print("After function call:", original_list)  # 함수 호출 후 리스트 출력

# 주소값이 복사 / 같은 메모리 상을 참조하게 됨 

# 제일 중요한 것은 파이썬은 모든 변수가 다 메모리에 저장 
#  a = 10이라면, 변수 a는 숫자 10 객체를 참조하는 변수입니다. 
#  즉, a는 10이라는 값을 가리키는 참조값

# 불변 객체 vs 가변 객체 
# 불변 객체 = 숫자, 문자열, 튜플 등이 불변 객체 = 값이 변경될 수 없다

# 불변 객체는 변수에 할당할 때, 
# 실제 객체의 복사본을 만드는 것이 아니라 참조를 전달합니다. 
# 그러나 불변 객체의 경우, 변수에 다시 할당하면 새로운 객체가 생성됩니다.

# 아 그니깐 불변 객체는 값을 변경하는 순간 값이 바뀔 수 없으므로 그냥 아예 메모리상에 새로운 객체가 생성 
# 자바 기준으로 return에 new가 붙었다고 생각하면 됨 

# 가변 객체는 값이 변경될 수 있는 객체입니다. 예를 들어, 리스트, 딕셔너리, 집합 등이 가변 객체

a = [1, 2, 3]  # 'a'는 리스트 객체를 참조
b = a  # 'b'도 같은 리스트 객체를 참조
print(id(a), id(b))  # 'a'와 'b'는 동일한 객체를 참조하므로 같은 id

b.append(4)  # 'b'에서 리스트를 수정
print(a)  # 'a'도 수정된 결과를 출력, 원본 리스트도 바뀌었음

# 변수가 저장하는 것은 객체 자체가 아니라 객체의 참조값입니다. 
# 즉, 변수가 참조하는 주소가 객체의 위치

# 파이썬에서 모든 것은 객체이기 때문에, 
# 타입도 클래스라는 객체로 취급되며, 객체는 항상 어떤 클래스의 인스턴스
# int는 클래스 객체이고, 그 클래스에서 만들어진 인스턴스가 a = 10입니다.


# 네, 정확합니다! 파이썬에서는 **상수(constant)**라는 개념이 언어적으로 존재하지 않습니다. 
# 대신, 모든 값은 객체로 취급되며, 이 객체가 가변인지 불변인지에 따라 동작이 달라진다.

# 가변객체
# list(리스트), dict(딕셔너리), set(집합), 바이트 배열

# 불변객체 
# int(정수), 부동소수점(float), 문자열(str), 튜플(tuple)

print(5/3)  # 나누기
print(5//3) # 몫
print(2**3) # 제곱 
print(7%3) # 나머지

# 문자열 = str 자료형 

a = "ac"
print(type(a)) # str 
print(a*3) # acacac 
len(a) # 파이썬에서 제공하는 함수 len -> class는? 

# \n -> 줄바꿈 문자 

# 문자열 슬라이싱
# a[::] # 이상 미만 간격
# a[::-2] # 거꾸로 

# 문자열 = immutable = 불변객체 

# 소수점 표현하기
# 0.4f -> 소숫점 4째자리까지 표현 

# 문자열 
a = 'hobby'
print(a.count('b')) # 2 

print(a.find('b')) #2 -> index 번호 찾기

a = ",".join('abcd') # a,b,c,d # 문자열 사이에 삽입
a = ",".join(['a','b','c']) # 리스트 사이에 삽입, 끝은 x 

a = "hi"
a.lstrip() # 왼쪽 공백 제거 
a.replace("ac", "bc") # ac 대신 bc로 교체 

a = "Life is too short"
a.split() # ['Life', 'is', 'too', 'short'] # 쪼개진 상태로 리스트가 나옴 

a.split(":") # :을 기준으로 나누기 

# 리스트 = 변수 여러개 담기
# 리스트의 주소값은? 

odd = [1,3,5,7,9]
type(odd) # <class, list>

e = [1,2,'life','is'] # 문자형 자료형, 숫자형 자료형 섞어서 한 번에 담을 수 있다
e = [1,[1,2],3] # 숫자형 자료형 

e[1][2] # 자바 기준으로는 체이닝 기법으로 주소값으로 접근인 듯 

# 문자열의 핵심은 문자열 자료형 

a[2:5] # 인덱싱 슬라이싱 

a = [1, 2, 3]

# 리스트 자체의 주소값
print(id(a))  # 리스트 객체 자체의 메모리 주소

# 각 요소의 주소값
print(id(a[0]))  # 첫 번째 요소 (1)의 메모리 주소
print(id(a[1]))  # 두 번째 요소 (2)의 메모리 주소
print(id(a[2]))  # 세 번째 요소 (3)의 메모리 주소

# 파이썬에서 서로 다른 자료형은 더할 수 없다 <-> TypeError
# str(3) -> 자료형 변환 




